# -*- coding: utf-8 -*-
"""summer_analytics.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15H65S6D60mYFFeWVfxk9SFFyuOzU44mk
"""

!pip install pathway bokeh --quiet

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import datetime
from datetime import datetime
import pathway as pw
import bokeh.plotting
import panel as pn

pn.extension()

df = pd.read_csv("/content/dataset.csv")    #this will show sample dataset
df

# Combining the 'LastUpdatedDate' and 'LastUpdatedTime' columns into a single datetime column
df['Timestamp'] = pd.to_datetime(df['LastUpdatedDate'] + ' ' + df['LastUpdatedTime'],
                                  format='%d-%m-%Y %H:%M:%S')

# Sort the DataFrame by the new 'Timestamp' column and reset the index
df = df.sort_values('Timestamp').reset_index(drop=True)
df

df.columns = [
    "Index", "ParkingLotID", "Capacity", "Latitude", "Longitude", "Occupancy",
    "VehicleType", "TrafficLevel", "QueueLength", "IsSpecialDay",
    "LastUpdatedDate", "LastUpdatedTime", "Timestamp"
]


# Save the selected columns to a CSV file for streaming or downstream processing
df[[
    "Timestamp",
    "ParkingLotID",
    "Capacity",
    "Occupancy",
    "QueueLength",
    "TrafficLevel",
    "IsSpecialDay",
    "VehicleType",
    "Latitude",
    "Longitude"
]].to_csv("parking_stream.csv", index=False)

df1= pd.read_csv("/content/parking_stream.csv")
df1

#updating my pathway schemma to reflect the new strcuture

# Defined the schema for the streaming data using Pathway
# This schema specifies the expected structure of each data row in the stream
class ParkingSchema(pw.Schema):
    Timestamp: str
    ParkingLotID: str
    Capacity: int
    Occupancy: int
    QueueLength: int
    TrafficLevel: str
    IsSpecialDay: int
    VehicleType: str
    Latitude: float
    Longitude: float

# Load the data as a simulated stream using Pathway's replay_csv function
# This replays the CSV data at a controlled input rate to mimic real-time streaming
# input_rate=1000 means approximately 1000 rows per second will be ingested into the stream.

data = pw.demo.replay_csv("parking_stream.csv", schema=ParkingSchema, input_rate=1000)
data

# Define the datetime format to parse the 'Timestamp' column
fmt = "%Y-%m-%d %H:%M:%S"

# Add new columns to the data stream:
# - 't' contains the parsed full datetime
# - 'day' extracts the date part and resets the time to midnight (useful for day-level aggregations)
data_with_time = data.with_columns(
    t = data.Timestamp.dt.strptime(fmt),
    day = data.Timestamp.dt.strptime(fmt).dt.strftime("%Y-%m-%dT00:00:00")
)

# Define a daily tumbling window over the data stream using Pathway
# This block performs temporal aggregation and computes a dynamic price for each day
import datetime

# Daily tumbling window for each parking lot
delta_window = (
    data_with_time.windowby(
        pw.this.t,                            # Event time column to use for windowing (parsed datetime)
        instance=pw.this.day + "_" + pw.this.ParkingLotID,  # Grouping key: day + parking lot
        window=pw.temporal.tumbling(datetime.timedelta(days=1)),# Fixed-size daily window
        behavior=pw.temporal.exactly_once_behavior()   # Guarantees exactly-once processing semantics
    )
    .reduce(
        ParkingLotID=pw.reducers.any(pw.this.ParkingLotID),#  retain lot ID for downstream logic
        t=pw.this._pw_window_end,                               # window end timestamp
        occ_max=pw.reducers.max(pw.this.Occupancy),  # Highest occupancy observed in the window
        occ_min=pw.reducers.min(pw.this.Occupancy),  # Lowest occupancy observed in the window
        cap=pw.reducers.max(pw.this.Capacity)        # Maximum capacity observed (typically constant per spot)
    )
    .with_columns(
        # Pricing logic
        price= 10 + (pw.this.occ_max - pw.this.occ_min) / pw.this.cap
    )
)

# Activate Panel extension for interactive Bokeh interactivity
pn.extension()

# Define a custom Bokeh plotting function that takes a data source (from Pathway) and returns a figure
def price_plotter(source):
      # Create a Bokeh figure with datetime x-axis
    fig = bokeh.plotting.figure(
        height=400,
        width=800,
        title="Pathway: Daily Parking Price per Lot",
        x_axis_type="datetime"  # Ensure time-based data is properly formatted on the x-axis
    )
    # Plot a line graph showing how the price evolves over time
    fig.line("t", "price", source=source, line_width=2, color="navy", legend_label="Price")

    # Overlay red circles at each data point for better visibility
    fig.circle("t", "price", source=source, size=6, color="red")

    fig.legend.location = "top_left"  # for location
    fig.xaxis.axis_label = "Date"     # for label date
    fig.yaxis.axis_label = "Price ($)"  # for lable price

    return fig

# Filter the data stream to a specific ParkingLotID
lot_id = "Others-CCCPS98"

filtered_window = delta_window.filter(pw.this.ParkingLotID == lot_id)

# Plot for that lot
viz = filtered_window.plot(price_plotter, sorting_col="t")
pn.Column(viz).servable()

# Commented out IPython magic to ensure Python compatibility.
# # Start the Pathway pipeline execution in the background
# # - This triggers the real-time data stream processing defined above
# # - %%capture --no-display suppresses output in the notebook interface
# 
# %%capture --no-display
# pw.run()

"""# ** Interactive Parking Lot Selector with Bokeh + Panel**"""

# Extract all unique parking lot IDs from the source data (static Pandas fallback for setup)
lot_ids = df1["ParkingLotID"].unique().tolist()
lot_ids.sort()
print(lot_ids)

# Create a dropdown selector with all ParkingLotIDs
lot_dropdown = pn.widgets.Select(name="Select Parking Lot", options=lot_ids)

@pn.depends(lot_dropdown)
def dynamic_price_plot(selected_lot):
    filtered = delta_window.filter(pw.this.ParkingLotID == selected_lot)

    # Define the Bokeh plot for the filtered stream
    def plot_fn(source):
        fig = bokeh.plotting.figure(
            height=400,
            width=800,
            title=f"Daily Price Trend: {selected_lot}",
            x_axis_type="datetime"
        )
        fig.line("t", "price", source=source, line_width=2, color="navy", legend_label="Price")
        fig.circle("t", "price", source=source, size=6, color="red")
        fig.legend.location = "top_left"
        fig.xaxis.axis_label = "Date"
        fig.yaxis.axis_label = "Price ($)"
        return fig

    return filtered.plot(plot_fn, sorting_col="t")

#this will display the dashboard
pn.Column(
    pn.pane.Markdown("### ðŸ“Š Dynamic Parking Lot Price Viewer"),
    lot_dropdown,
    dynamic_price_plot
).servable()

# Commented out IPython magic to ensure Python compatibility.
# # Start the Pathway pipeline execution in the background
# # - This triggers the real-time data stream processing defined above
# # - %%capture --no-display suppresses output in the notebook interface
# 
# %%capture --no-display
# pw.run()

from google.colab import drive
drive.mount('/content/drive')

"""# **Model 2 â€“ Demand-Based Pricing**"""

# Constants for demand function
alpha = 0.4   # Occupancy
beta = 0.3    # Queue length
gamma = 0.2   # Traffic level
delta = 0.3   # Special day
epsilon = 0.5 # Vehicle type weight
lambda_ = 0.8 # Sensitivity of price to demand

base_price = 10

# Vehicle type weights
vehicle_type_weight = {
    "car": 1.0,
    "bike": 0.5,
    "cycle": 0.5,   # use cycle as same as bike
    "truck": 1.5
}

# Traffic level mapping
traffic_map = {
    "low": 0.2,
    "average": 0.5,
    "high": 1.0
}

import datetime

# Step 1: Group by lot and day (daily tumbling window)
demand_window = (
    data_with_time.windowby(
        pw.this.t,
        instance=pw.this.day + "_" + pw.this.ParkingLotID,
        window=pw.temporal.tumbling(datetime.timedelta(days=1)),
        behavior=pw.temporal.exactly_once_behavior()
    )
    .reduce(
        t=pw.this._pw_window_end,
        ParkingLotID=pw.reducers.any(pw.this.ParkingLotID),
        Occupancy=pw.reducers.max(pw.this.Occupancy),
        Capacity=pw.reducers.max(pw.this.Capacity),
        QueueLength=pw.reducers.max(pw.this.QueueLength),
        IsSpecialDay=pw.reducers.any(pw.this.IsSpecialDay),
        VehicleType=pw.reducers.any(pw.this.VehicleType),
        TrafficLevel=pw.reducers.any(pw.this.TrafficLevel),
    )
)

# Step 2: Compute occupancy rate
step1 = demand_window.with_columns(
    occ_rate = pw.this.Occupancy / pw.this.Capacity
)

# Step 3: Map vehicle and traffic types
step2 = step1.with_columns(
    veh_weight = pw.apply(lambda v: vehicle_type_weight.get(v.lower(), 1.0), pw.this.VehicleType),
    traffic_value = pw.apply(lambda t: traffic_map.get(t.lower(), 0.5), pw.this.TrafficLevel)
)

step3a = step2.with_columns(
    term_occ = pw.apply(lambda x: alpha * x, pw.this.occ_rate),
    term_queue = pw.apply(lambda x: beta * x / 5.0, pw.this.QueueLength),
    term_traffic = pw.apply(lambda x: -gamma * x, pw.this.traffic_value),
    term_special = pw.apply(lambda x: delta * x, pw.this.IsSpecialDay),
    term_vehicle = pw.apply(lambda x: epsilon * x, pw.this.veh_weight),
)

step3b = step3a.with_columns(
    raw_demand = pw.apply(
        lambda occ, queue, traffic, special, veh: occ + queue + traffic + special + veh,
        pw.this.term_occ,
        pw.this.term_queue,
        pw.this.term_traffic,
        pw.this.term_special,
        pw.this.term_vehicle,
    )
)

step4a = step3b.with_columns(
    normalized_demand = pw.apply(
        lambda d: d / (1 + abs(d)),
        pw.this.raw_demand
    )
)

step4b = step4a.with_columns(
    unclipped_price = pw.apply(
        lambda d: base_price * (1 + lambda_ * d),
        pw.this.normalized_demand
    )
)

step4 = step4b.with_columns(
    price = pw.apply(
        lambda p: max(0.5 * base_price, min(2.0 * base_price, p)),
        pw.this.unclipped_price
    )
)

@pn.depends(lot_dropdown)
def interactive_plot(selected_lot):
    # Filter the model 2 price data for the selected lot
    filtered = step4.filter(pw.this.ParkingLotID == selected_lot)

    # Use the same plotter function you already defined
    return filtered.plot(price_plotter, sorting_col="t")

dashboard = pn.Column(
    "# Model 2: Demand-Based Dynamic Pricing",
    lot_dropdown,
    interactive_plot
)
dashboard.servable()

pw.run()

# Commented out IPython magic to ensure Python compatibility.
# %%capture --no-display
# pw.run()